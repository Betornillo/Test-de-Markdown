<div style="text-align: justify">

# Servidor VPN: Guía de instalación

## Introducción
Una **VPN (Virtual Private Network)** es un túnel seguro entre su dispositivo y 
la internet. Las VPN se usan para proteger el tráfico privado por internet contra
espías, interferencias y censura; además, permite desplazarnos por redes no 
confiables de manera privada y segura, como si estuviéramos en una red privada.
El tráfico se inicia en el servidor de la VPN y continúa su camino hacia el
destino.

Cuando se combina con *conexiones HTTPS*, esta configuración permite proteger los 
inicios de sesión y las operaciones que realizamos por medios inalámbricos. 
Podemos evadir censuras y restricciones geográficas, y proteger nuestra ubicación 
y el tráfico de *HTTP* no cifrado contra la actividad de la red no confiable.

A través de este tutorial, configuraremos un servidor de **OpenVPN** en un 
servidor **Linux Mint Debian Edition 4** y luego el acceso a él desde Windows, 
macOS o Linux.

## Requisitos previos
Para completar con éxito este tutorial, necesitaremos acceso a un servidor 
**Linux Mint Debian Edition 4** con el fin de alojar nuestro servicio de 
**OpenVPN**.  Además, necesitaremos una máquina aparte (se recomienda usar una 
máquina virtual) para que funcione como su autoridad de certificación **CA**.

### Configuración de la dirección IP estática en Linux Mint
1. Actualizar sistema.
> $ sudo apt-get update && sudo apt-get upgrade

2. Conocer las interfaces de red que tenemos en la máquina.
> $ ifconfig -a

> enp0s3: flags=4163<UP, BROADCAST, RUNNING, MULTICAST> mtu 1500
> 
> inet 192.168.42.18 netmask 255.255.255.0 broadcast 192.168.42.255
> 
> inet6 fe80::2244:2b06:3e64:dd0d prefixlen 64 scopeid 0x20<link>
> 
> ether 08:00:27:a8:cf:ca txqueuelen 1000 (Ethernet)
> 
> RX packets 362804 bytes 528542352 (504.0 MiB) 
>
> RX errors 0 dropped 0 overruns 0 frame 0
> 
> TX packets 165227 bytes 11820487 (11.2 MiB)
>
> TX erros 0 dropped 0 overruns 0 carrier 0 collisions 0

> lo: flags=73<UP, LOOPBACK, RUNNING> mtu 65536
> 
> inet 127.0.0.1 netmask 255.0.0.0
> 
> inet6 ::1 prefixlen 128 scopeid 0x10<host>
> 
> loop txqueuelen 1000 (Local Loopback)
> 
> RX packets 168 bytes 13356 (13.0 KiB) 
>
> RX errors 0 dropped 0 overruns 0 frame 0
> 
> TX packets 168 bytes 13356 (13.0 KiB)
>
> TX erros 0 dropped 0 overruns 0 carrier 0 collisions 0

En este caso, podemos observar que nuestra interfaz de red es `enp0s3` (en caso
de contar con más adaptadores de red, veremos sus respectivos `IDs`) y su
dirección *IP* es `192.168.42.18`. Además, notemos que tenemos una interfaz de 
red de *loopback* con la abreviatura `lo`, que sirve para comprobar si tenemos 
conectividad con nuestra propia máquina en la dirección *IP* `127.0.0.1`.  

3. Crear una copia de seguridad del archivo `/etc/network/interfaces`.
> $ sudo cp /etc/network/interfaces /etc/network/interfaces.example

4. Abrir el archivo `/etc/network/interfaces`. 
> $ sudo nano /etc/network/interfaces

> \# interfaces(5) file used by ifup(8) and ifdown(8)
> 
> \# Include files from /etc/network/interfaces.d:
> 
> source-directory /etc/network/interfaces.d

Este es el archivo de configuración de las interfaces de red. En nuestro caso, 
la interfaz de red que queremos configurar es `enp0s3`. 

5. Agregar la configuración de interfaz de red.
> \# Configuración de dirección IP fija para la interfaz enp0s3
> 
> allow-hotplug enp0s3
> 
> iface enp0s3 inet static
> 
> address 192.168.42.18
> 
> netmask 255.255.255.0
> 
> network 192.168.42.0
> 
> broadcast 192.168.42.255
> 
> gateway 192.168.42.129

donde 
* **adress** es la dirección *IP* que quieres ponerle a tu máquina.
* **netmask** es la máscara de subred de esa dirección *IP*.
* **network** es la red a la que pertenece esa dirección *IP*.
* **broadcast** es la dirección *IP* de difusión de esa red.
* **gateway** es la dirección *IP de la puerta de enlace predeterminada.
  
Guardamos y cerramos el archivo. 

6. Reiniciar las interfaces de red de nuestra máquina para aplicar los cambios.
> $ sudo service networking restart
> 
> $ sudo /etc/init.d/networking restart

7. Reiniciar nuestra máquina. 
> $ sudo reboot

8. Abrimos el archivo `/etc/resolv.conf`.
> $ sudo nano /etc/resolv.conf

> \# Generated by NetworkManager
> 
> nameserver 192.168.42.129

9. Agregamos la configuración de la dirección *IP* del servidor *DNS*.  
> \# Generated by NetworkManager
> 
> **domain home.lan**
> 
> **search home.lan**
> 
> nameserver 192.168.42.129

Guardamos y cerramos el archivo. 

10. Reiniciar la interfaz de red para aplicar la nueva configuración.
> $ sudo ifup enp0s3

11. Reiniciar la máquina.
> $ sudo reboot

### Configuración de usuarios
Debemos configurar, en ambas máquinas, un usuario no **root** con privilegios 
*sudo* y un **firewall** básico. 

Para nuestra máquina **Linux Mint**, la configuración se hace de la siguiente 
manera:

#### Configuración del servicio SSH.
1. Verificar que no haya actualizaciones pendientes.
> $ sudo apt-get update

2.  Instalar el servidor y cliente OpenSSH.
> $ sudo apt install openssh-server openssh-client

3. Iniciamos el servicio.
> $ sudo service ssh restart

4. Iniciamos el demonio *SSH*.
> $ sudo service sshd start

5. Cambiar el puerto del servidor *SSH*.

Para la seguridad de nuestro servidor Linux, es imprescindible realizar el
cambio del puerto de *SSH*. Por defecto, *SSH* corre sobre el puerto `22`.

Abrimos el archivo `/etc/ssh/sshd_config`
> $ sudo nano /etc/ssh/sshd_config

Buscamos la línea que hace referencia al puerto, la cual debería de estar 
comentada.
> \# Port 22

Descomentamos la línea y cambiamos el número `22` por otro (lo recomendable es 
uno mayor a `1024`). En este caso, nosotros asignaremos el puerto `22445`.
> Port 22445

6. Configurar la autenticación con contraseña.
   
Buscamos la línea `PermitRootLogin`. Debería estar comentada, acompañada de la 
palabra `prohibit-password` o `without-password` o `no`. En nuestro caso, 
aparece de la siguiente forma
> \# PermitRootLogin prohibit-password

La descomentamos y lo reescribimos de tal forma que se permita la autenticación
con contraseña, es decir, 
> PermitRootLogin yes

Guardamos y cerramos el archivo. Reiniciamos el servicio.
> $ sudo systemctl restart sshd.service

7. Reiniciar la máquina.
> $ sudo reboot

#### Configuración del usuario.
1. Iniciar sesión como *root* en el servidor.
> $ ssh root@your_server_ip -p 22445

donde `your_server_ip` lo podemos obtener al teclear en la terminal `hostname -I`.

A continuación se solicitará la contraseña del usuario `root`. En caso de que su 
contraseña no funcione, podemos cambiarla fácilmente usando `$ sudo passwd root`.

2. Crear un nuevo usuario.

Una vez que hayamos iniciado sesión como **root**, estamos listos para agregar 
la cuenta de usuario que usaremos para iniciar sesión a partir de ahora.

Este ejemplo crea un nuevo usuario llamado **rubi**.
> \# adduser rubi

Se nos hará un par de preguntas, comenzando con la contraseña de la cuenta. Esto 
no es necesario, y podemos sólo pulsar `ENTER` en cualquier campo que deseemos
omitir. 

3. Conceder privilegios administrativos.
 
Ahora tenemos una nueva cuenta de usuario con privilegios de cuenta regulares. 
Sin embargo, a veces podemos necesitar hacer tareas administrativas. Para evitar
tener que cerrar sesión en nuestro usuario normal y volver a iniciar sesión como 
usuario **root**, podemos configurar privilegios **root** para nuestra cuenta 
normal. Esto permitirá a nuestro usuario normal ejecutar comandos con privilegios
administrativos al poner la palabra *sudo* antes de cada comando.

Para agregar estos privilegios a nuestro nuevo usuario, necesitamos agregar el
nuevo usuario al grupo *sudo*. 

Como *root*, ejecute este comando para agregar el nuevo usuario al grupo *sudo*
> \# usermod -aG sudo **rubi**

Modificamos la palabra resaltada con nuestro nuevo usuario.

4. Agregar la autenticación de llave pública.

Abrimos el archivo `/etc/ssh/sshd_config`, buscamos la línea 
`PubKeyAuthentication`. Debería de estar comentada, acompañada de la palabra 
`yes`.
> \# PubkeyAuthentication yes

La descomentamos. En caso de que tengo un parámetro diferente a `yes`, simplemente
lo modificamos. Guardamos y cerramos el archivo.

Ahora, creamos un par de llaves RSA. 
> $ ssh-keygen -b 4096

Por defecto, `ssh-keygen` creará un par de claves *RSA* de `3072` bits, que es lo
suficientemente seguro para la mayoría de casos de uso (opcionalmente se puede 
pasar el indicador `-b 4096` para crear una clave de `4096` bits más grande).

Después de ingresar el comando, veremos el siguiente resultado
> Generating public/private rsa key pair. 
>
>  Enter file in which to save the key (/root/.ssh/id_rsa):

Presionamos `ENTER` para guardar el par de claves de *SSH* en el subdirectorio 
`.ssh/` de nuestro directorio principal. Si previamente hemos generado un par de 
llaves *SSH*, se nos dará la opción de sobreescribir la clave en el disco 
(aunque ya no se podrá autenticar usando la clave anterior).  

Luego, deberíamos ver el siguiente mensaje
> Enter passphrase (empty for no passphrase):

Aquí, se puede introducir una frase de contraseña segura, lo cual se recomienda 
mucho. Una frase de contraseña agrega una capa de seguridad adicional para evitar el inicio de sesión de usuarios no autorizados.

Ahora dispondremos de una clave pública y privada que se puede usar para realizar
la autenticación. 

Copiamos nuestra clave pública con el comando 
> $ ssh-copy-id rubi@remote_host -p 22445

donde `remote_host` lo obtenemos al escribir en la terminal `hostname -I`.

Nos debería de aparecer un mensaje como este
> The authenticity of host '[your_remote_host]:22445 ([your_remote_host]:22445)'
>  can't be established. 
> 
> ECDSA key fingerprint is SHA256:XpTNSoU4upetId5oGe41kgV1xqCTtWlb0UmeHSaJ1Pk.
> 
> Are you sure you want to continue connecting (yes/no)? 

Esto significa que nuestra computadora local no reconoce el host remoto. Esto 
sucederá la primera vez que establezcamos conexión con un nuevo host. Escribimos
`yes`, y presionamos `ENTER` para continuar. 

Una vez que la utilidad encuentre la clave `id_rsa.pub` que creamos antes, nos 
solicitará una contraseña de la cuenta del usuario remoto:
> /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter 
> out any that are already installed
>
> /usr/bin/ss-copy-id: INFO: 1 key(s) remain to be installed -- if you are 
> prompted now it is to install the new keys
> 
> root@your_remote_host's password:

Escribimos la contraseña correspondiente al usuario **root**, y pulsamos `ENTER`.
La utilidad se conectará a la cuenta en el host remoto usando la contraseña que 
proporcionó. Luego, se copia el contenido de la clave `~/.ssh/id_rsa.pub` a un 
archivo en el directorio principal de la cuenta remota `~/.ssh`, llamado 
`authorized_keys`.

Después deberíamos ver el siguiente resultado:
> Number of key(s) added: 1
> 
> Now try logging into the machine, with: "ssh -p '22445' 'rubi@your_remote_host'"
> and check to make sure that only the key(s) you wanted were added.

En este punto, nuestra clave `id_rsa.pub` se habrá cargado en la cuenta remota.
   
Si se completó con éxito el paso anterior, debería poder iniciar sesión en el
host remoto sin contraseña de la cuenta remota.

El proceso básico es el mismo:
> $ ssh rubi@your_remote_host -p 22445

Si no se proporcionó una frase de contraseña para la clave privada, se iniciará 
sesión de inmediato. En caso contrario, se nos solicitará introducirla ahora.
Después de la autenticación, se debería abrir una nueva sesión de shell con la 
cuenta configurada en el servidor de *Linux Mint*. 

De manera opcional, se puede abrir el archivo `/etc/ssh/sshd_config` y buscar la
línea `PasswordAuthentication`. Debería de estar comentada.
> \# PasswordAuthentication no

La descomentamos. Esto deshabilitará su capacidad de iniciar sesión vía *SSH* 
usando las contraseñas de la cuenta.

5. Configurar **firewall** básico.

Los servidores *Linux Mint* pueden usar el firewall *UFW* para asegurarse de que 
sólo se permitan conexiones a ciertos servicios.

OpenSSH tiene un perfil registrado registrado con *UFW*. Para ver esto, tecleamos
> $ sudo ufw app list

Necesitamos asegurarnos de que el *firewall* permita conexiones *SSH* para que 
podamos volver a conectarnos la próxima vez. Podemos permitir esas conexiones 
escribiendo:
> $ sudo ufw allow OpenSSH

Además, como cambiamos el puerto en que se conecta, debemos habiliarlo:
> $ sudo ufw allow 22445

Posteriormente, habilitamos el *firewall*.
> $ sudo ufw enable

Escribimos `y` y presionamos `ENTER`. Para ver que las conexiones *SSH* todavía
se permiten, escribimos
> $ sudo ufw status

6. De manera análoga, realizamos la misma configuración para nuestra máquina 
   **CA** (en este caso, utilizamos **Ubuntu 20.04**).

## Paso 1: Instalar OpenVPN e EasyRSA

</div>